<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Adaptive Quiz & Flow Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            background: #f5f5f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        #intro-container, #quiz-container {
            max-width: 700px; /* Slightly wider for better content display */
            padding: 30px; /* More padding */
            background: #ffffff;
            border-radius: 10px; /* Softer corners */
            box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.15); /* More prominent shadow */
            text-align: center;
            margin-bottom: 25px; /* Space between containers and SVG */
            width: 100%; /* Take full width up to max-width */
        }
        h1 {
            color: #0079c1;
            font-weight: 600;
            margin-bottom: 20px;
        }
        p {
            color: #555;
            line-height: 1.6;
            margin-bottom: 25px;
        }
        .question {
            font-size: 1.3em; /* Slightly larger question text */
            font-weight: 500;
            margin-bottom: 20px;
            color: #333;
        }
        .start-btn, .option-btn {
            display: block;
            width: 100%;
            padding: 14px; /* More padding */
            font-size: 1.1em; /* Larger font size */
            font-weight: 500;
            background: #487da4;
            color: #fff;
            border: none;
            border-radius: 8px; /* Softer corners */
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease; /* Smooth transition */
            margin-bottom: 10px; /* Space between buttons */
        }
        .start-btn:hover, .option-btn:hover {
            background: #356489;
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* Shadow on hover */
        }
        .start-btn:active, .option-btn:active {
            background: #de9179;
            transform: translateY(0);
        }
        .option-btn:last-child {
            margin-bottom: 0; /* No margin after the last option */
        }

        svg {
            border: 1px solid #ddd; /* Lighter border for SVG */
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.05); /* Subtle shadow for SVG */
            background-color: #fcfcfc;
            overflow: visible; /* Allow content to go slightly outside bounds if needed for labels */
        }

        /* D3.js specific styles */
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
            transition: stroke-width 0.3s ease, stroke 0.3s ease;
        }
        .link.active-path {
            stroke: #0079c1; /* Active path color */
            stroke-width: 3px; /* Thicker active path */
        }

        .node circle {
            fill: #fff;
            stroke: #487da4;
            stroke-width: 3px;
            transition: stroke 0.3s ease, fill 0.3s ease, r 0.3s ease;
        }
        .node.current circle {
            fill: #de9179; /* Current node color */
            stroke: #b65f49;
            r: 25px; /* Slightly larger current node */
        }
        .node.visited circle {
            fill: #a9d2eb; /* Visited node color */
            stroke: #2e6fa5;
        }

        .node text {
            font-size: 0.9em; /* Smaller text for node labels */
            fill: #333;
            pointer-events: none; /* Prevent text from blocking mouse events on circle */
            text-shadow: 0 1px 0 rgba(255,255,255,0.8); /* For better readability on light circles */
        }
        .node.current text {
            font-weight: 600;
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            text-align: center;
            width: 160px; /* Adjusted width */
            height: auto;
            padding: 8px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            color: #333;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="intro-container">
        <h1>Welcome to the Adaptive Quiz</h1>
        <p>This visualization shows the possible paths through the quiz. As you answer questions, the path you take will be highlighted.</p>
        <button class="start-btn">Start Quiz</button>
    </div>

    <div id="quiz-container" style="display:none;">
        <div id="question-container" class="question"></div>
        <div id="options-container"></div>
    </div>

    <svg width="1200" height="800"></svg>
    <div class="tooltip" style="opacity:0;"></div>

    <script>
        // Define your quiz data
        // For D3, we need to map IDs to actual objects for hierarchy
        const quizData = [
            { id: "q1", question: "How familiar are you with data visualization?", options: ["Not at all", "Slightly", "Moderately", "Very"], next: { "Not at all": "q2", "Slightly": "q3", "Moderately": "q4", "Very": "q5" } },
            { id: "q2", question: "Which of these best describes your experience with programming?", options: ["None", "Beginner (e.g., Scratch, basic HTML)", "Intermediate (e.g., Python basics, JavaScript basics)", "Advanced (e.g., multiple languages, complex projects)"], next: { "None": "q3", "Beginner (e.g., Scratch, basic HTML)": "q3", "Intermediate (e.g., Python basics, JavaScript basics)": "q4", "Advanced (e.g., multiple languages, complex projects)": "q5" } },
            { id: "q3", question: "Are you comfortable with basic statistical concepts (mean, median, etc.)?", options: ["No", "Somewhat", "Yes"], next: { "No": "q4", "Somewhat": "q5", "Yes": "q6" } },
            { id: "q4", question: "Have you ever used a Geographic Information System (GIS) tool?", options: ["No", "Yes, occasionally", "Yes, regularly"], next: { "No": "q5", "Yes, occasionally": "q6", "Yes, regularly": "q7" } },
            { id: "q5", question: "What is your interest level in learning about AI applications?", options: ["Low", "Medium", "High"], next: { "Low": "end_basic", "Medium": "q6", "High": "q7" } },
            { id: "q6", question: "How confident are you in interpreting complex charts and graphs?", options: ["Not confident", "Moderately confident", "Very confident"], next: { "Not confident": "q7", "Moderately confident": "q7", "Very confident": "end_advanced" } },
            { id: "q7", question: "Which topic would you prefer to learn more about?", options: ["Data Cleaning", "Machine Learning Algorithms", "Interactive Dashboards", "Spatial Analysis"], next: { "Data Cleaning": "end_data_cleaning", "Machine Learning Algorithms": "end_ml", "Interactive Dashboards": "end_dashboards", "Spatial Analysis": "end_spatial" } }
            // Add 'end' nodes for demonstration, these will be treated as leaf nodes
            , { id: "end_basic", question: "End of Basic Path: You've completed the basic assessment!" }
            , { id: "end_advanced", question: "End of Advanced Path: Great insights!" }
            , { id: "end_data_cleaning", question: "End: Focus on Data Cleaning." }
            , { id: "end_ml", question: "End: Focus on Machine Learning Algorithms." }
            , { id: "end_dashboards", question: "End: Focus on Interactive Dashboards." }
            , { id: "end_spatial", question: "End: Focus on Spatial Analysis." }
        ];

        // Create a map for quick lookup of questions by ID
        const questionMap = new Map(quizData.map(q => [q.id, q]));

        // --- D3.js Visualization Setup ---
        const svgWidth = 1200;
        const svgHeight = 800;
        const margin = { top: 50, right: 50, bottom: 50, left: 50 };
        const innerWidth = svgWidth - margin.left - margin.right;
        const innerHeight = svgHeight - margin.top - margin.bottom;

        const treeLayout = d3.tree().size([innerWidth, innerHeight]);

        // Custom hierarchy function to handle non-standard 'next' structure
        // This creates a hierarchical structure based on your quiz logic
        function createQuizHierarchy(data) {
            // Find the root question (assuming "q1" is always the start)
            const rootNode = questionMap.get("q1");

            if (!rootNode) {
                console.error("Root question 'q1' not found in quizData.");
                return null;
            }

            // Function to recursively build children
            function buildChildren(nodeData) {
                if (nodeData.next) {
                    const children = Object.values(nodeData.next) // Get all possible next question IDs
                                          .filter(id => questionMap.has(id)) // Filter out non-existent IDs
                                          .map(id => questionMap.get(id)); // Get the actual question objects
                    return children;
                }
                return null;
            }

            return d3.hierarchy(rootNode, buildChildren);
        }

        const hierarchy = createQuizHierarchy(quizData);
        if (!hierarchy) {
            console.error("Failed to create D3 hierarchy. Visualization aborted.");
            document.querySelector("svg").style.display = "none"; // Hide SVG if hierarchy fails
        }

        const treeData = hierarchy ? treeLayout(hierarchy) : null;

        const svg = d3.select("svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight);

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Tooltip for hovering over nodes
        const tooltip = d3.select(".tooltip");

        let link, node; // Declare these globally or in a scope where updateVisualization can access them

        function drawVisualization() {
            if (!treeData) return;

            // Links
            link = g.selectAll(".link")
                .data(treeData.links(), d => d.target.data.id) // Use target id for key function for stable updates
                .join("path") // Use join for enter/update/exit
                .attr("class", "link")
                .attr("d", d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y));

            // Nodes
            node = g.selectAll(".node")
                .data(treeData.descendants(), d => d.data.id) // Use data id for key function for stable updates
                .join(
                    enter => {
                        const nodeEnter = enter.append("g")
                            .attr("class", "node")
                            .attr("transform", d => `translate(${d.x},${d.y})`);

                        nodeEnter.append("circle")
                            .attr("r", 20);

                        nodeEnter.append("text")
                            .attr("dy", 5)
                            .attr("text-anchor", "middle")
                            .text(d => d.data.id); // Display ID in circle by default, full question in tooltip

                        // Tooltip events
                        nodeEnter.on("mouseover", function(event, d) {
                            tooltip.style("opacity", 1)
                                .html(`<strong>${d.data.id}:</strong><br>${d.data.question || "End of path"}`)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function() {
                            tooltip.style("opacity", 0);
                        });

                        return nodeEnter;
                    },
                    update => update.attr("transform", d => `translate(${d.x},${d.y})`), // Update position
                    exit => exit.remove()
                );

            updateVisualization(); // Initial update to highlight current/visited
        }

        // --- Quiz Logic ---
        const startButton = document.querySelector(".start-btn");
        const introContainer = document.getElementById("intro-container");
        const quizContainer = document.getElementById("quiz-container");
        const questionContainer = document.getElementById("question-container");
        const optionsContainer = document.getElementById("options-container");

        let currentQuestionId = "q1"; // Start with the first question
        let visitedNodes = new Set();
        let pathLinks = new Set(); // Stores objects like {sourceId, targetId} or actual D3 link objects

        function startQuiz() {
            introContainer.style.display = "none";
            quizContainer.style.display = "block";
            loadQuestion(currentQuestionId);
            drawVisualization(); // Draw the D3 viz once quiz starts
        }

        function loadQuestion(questionId) {
            const question = questionMap.get(questionId);

            if (!question) {
                // This means it's an 'end' node or an invalid ID
                questionContainer.textContent = "Quiz Completed!";
                optionsContainer.innerHTML = `<p>Thank you for participating! ${questionMap.get(questionId).question}</p>`;
                currentQuestionId = null; // Mark quiz as ended
                updateVisualization(); // Update visualization to show final state
                return;
            }

            currentQuestionId = questionId;
            visitedNodes.add(questionId); // Mark current node as visited

            questionContainer.textContent = question.question;
            optionsContainer.innerHTML = ''; // Clear previous options

            if (question.options) { // Only show options if the question has them
                question.options.forEach(option => {
                    const button = document.createElement("button");
                    button.classList.add("option-btn");
                    button.textContent = option;
                    button.onclick = () => handleAnswer(option, question);
                    optionsContainer.appendChild(button);
                });
            } else {
                // For 'end' nodes that might not have options
                optionsContainer.innerHTML = `<p>This path concludes here. Refresh to restart.</p>`;
            }

            updateVisualization(); // Update the D3 visualization after loading a new question
        }

        function handleAnswer(selectedOption, currentQ) {
            const nextQuestionId = currentQ.next[selectedOption];

            if (nextQuestionId) {
                // Add the link to the path
                pathLinks.add(JSON.stringify({ source: currentQ.id, target: nextQuestionId }));
                loadQuestion(nextQuestionId);
            } else {
                // Should not happen if quizData.next is well-defined
                console.warn("No next question defined for this option.");
                // Optionally, end the quiz here or show an error
                questionContainer.textContent = "Error: No next question found.";
                optionsContainer.innerHTML = '';
            }
        }

        // --- D3.js Visualization Update Function ---
        function updateVisualization() {
            if (!node || !link) return; // Ensure visualization elements exist

            // Update node styles
            node.classed("current", d => d.data.id === currentQuestionId)
                .classed("visited", d => visitedNodes.has(d.data.id) && d.data.id !== currentQuestionId); // Visited but not current

            // Update link styles
            link.classed("active-path", d => {
                const linkKey = JSON.stringify({ source: d.source.data.id, target: d.target.data.id });
                return pathLinks.has(linkKey);
            });
        }

        // Event listener for the start button
        startButton.addEventListener("click", startQuiz);

        // Initial drawing of the visualization (optional, could be hidden until quiz starts)
        // If you want to show the full map before starting, call drawVisualization() here.
        // For this example, it's called in startQuiz().
        // drawVisualization();
    </script>
</body>
</html>
